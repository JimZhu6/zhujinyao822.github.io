{"pages":[{"title":"","text":"关于本站​ 目前处于建站初期阶段，欢迎您提供建议，我将尽最大能力完善本站 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"分类","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/categories/index.html"},{"title":"标签","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/tags/index.html"}],"posts":[{"title":"vscode插件Settings Sync使用介绍","text":"Settings Sync是一个能通过github同步电脑里vscode插件的插件，方便更换电脑时同步vscode里的插件 下载​ 在vscode的扩展商店里搜索Settings Sync安装 安装（上传数据）​ 插件安装完成后，按alt+shift+U键，vscode里会跳出窗口让你输入内容，同时还会打开github的个人令牌页面。点击generate new token创建新的个人令牌 ​ 提示：若此时你没有登录github，请先登录，然后进入设置，进入个人令牌页面 ​ 令牌的名字随意，自己能分辨出来就好。下面的选项只勾选gist一个 ​ 点击下方的generate token ，创建个人令牌。 ​ 然后github会生成一段代码，请记录好这段代码 。将这段代码复制到vscode的弹窗里。 ​ 按回车键，稍等片刻。 ​ 直到vscode弹出提示信息，请记录好这段提示信息 。 ​ 截止目前，你的vscode里所有的插件信息已经保存到github。 安装（下载/同步数据）​ 在你需要同步的vscode里下载Settings Sync。安装完成后，按alt+shift+D键，跳出提示框。根据提示，先输入github的令牌地址，也就是在github网页上复制的那行代码。 ​ 然后再输入gistID，也就是在vscode弹出提示里的那段代码。 ​ 然后稍等片刻，同步完成。 上图是本地插件列表与github上的插件无区别的提示 重置​ 如果中途发现输错id，可以使用重置功能 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/91b27d98.html"},{"title":"http无状态概念","text":"关键词：状态 状态 是指客户端与服务端之间连接所产生的数据。标准的http协议是无状态和无连接的。 关键词：连接 ​ 连接 是指客户端向服务器发送的请求，服务器接收到请求后做出响应。无连接指的是服务器每次连接只会处理一个请求，处理完成后，就断开当前连接。 ​ 那么，无状态产生的问题就是，服务器对客户端无任何“印象”，举个例子： 客户端：你今天中午吃什么？ 服务器：吃了白切鸡。 客户端：味道怎么样呀？ 服务器：？？？啊？你说的是什么？ ​ 相当于在用户在登录某个网站的时候，客户端发送了用户的账号密码，但服务器瞬间就没有这个“印象”，造成了这个极大的不便 ​ 那么这时，cookies，session的出现就改变了这一局面，利用cookies存储在客户端的信息，服务器就能分辨出每个客户端的不同，同时为每个客户端提供独立的服务。 服务器对客户端生成cookies流程： 参考文章：https协议无状态中的 “状态” 到底指的是什么？！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/1eeccae2.html"},{"title":"MD模板","text":"Getting the Gist of Markdown’s Formatting Syntax此页提供了 Markdown 的简单概念， 语法说明 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。 其实直接试试看也是一个很不错的方法， Dingus 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;‘ 角括号。 Markdown 语法: A First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog&apos;s back. ### Header 3 &gt; This is a blockquote. &gt; &gt; This is the second paragraph in the blockquote. &gt; &gt; ## This is an H2 in a blockquote 输出 HTML 为： &lt;h1&gt;A First Level Header&lt;/h1&gt; &lt;h2&gt;A Second Level Header&lt;/h2&gt; &lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt; &lt;p&gt;The quick brown fox jumped over the lazy dog&apos;s back.&lt;/p&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;This is a blockquote.&lt;/p&gt; &lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt; &lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt; &lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法: Some of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为: &lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;. Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;. Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号： * Candy. * Gum. * Booze. 加号： + Candy. + Gum. + Booze. 和减号 - Candy. - Gum. - Booze. 都会输出 HTML 为： &lt;ul&gt; &lt;li&gt;Candy.&lt;/li&gt; &lt;li&gt;Gum.&lt;/li&gt; &lt;li&gt;Booze.&lt;/li&gt; &lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记： 1. Red 2. Green 3. Blue 输出 HTML 为： &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Green&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。 * A list item. With multiple paragraphs. * Another item in the list. 输出 HTML 为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt; &lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 链接Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接： This is an [example link](https://example.com/). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;https://example.com/&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性： This is an [example link](https://example.com/ &quot;With a Title&quot;). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;https://example.com/&quot; title=&quot;With a Title&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: https://google.com/ &quot;Google&quot; [2]: https://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: https://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为： &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;https://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;https://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;https://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写： I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: https://www.nytimes.com/ 输出 HTML 为： &lt;p&gt;I start my morning with a cup of coffee and &lt;a href=&quot;https://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）： ![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式： ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为： &lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码： I strongly recommend against using any `&lt;blink&gt;` tags. I wish SmartyPants used named entities like `&amp;mdash;` instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为： &lt;p&gt;I strongly recommend against using any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; &lt;p&gt;I wish SmartyPants used named entities like &lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded entites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法: If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes: &lt;blockquote&gt; &lt;p&gt;For example.&lt;/p&gt; &lt;/blockquote&gt; 输出 HTML 为： &lt;p&gt;If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt; &lt;/code&gt;&lt;/pre&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/203dfdcf.html"},{"title":"php端解决跨域问题","text":"记录了下在本地用wamp部署服务器时遇到的问题。 由于我前端页面与后端使用两个不同的域名空间，所以提示了下面的跨域问题： Access to XMLHttpRequest at ‘http://php.cc/tools/login/login&apos; from origin ‘http://demo.cc&apos; has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 遇到这个错误时，都能够马上想到解决方式了，在后端框架入口文件添加： 1header(&apos;Access-Control-Allow-Origin:http://demo.cc&apos;); 解决完这个问题后，在测试接口的时候又出现一个新的报错信息： Access to XMLHttpRequest at ‘http://php.cc/tools/login/login&apos; from origin ‘http://demo.cc&apos; has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response. 在网上搜到,需要添加上下面的这两行： 12header(&apos;Access-Control-Allow-Headers:content-type,token,id&apos;);header(&quot;Access-Control-Request-Headers: Origin, X-Requested-With, content-Type, Accept, Authorization&quot;); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/9c2031c1.html"},{"title":"vue小记（组件间的信息传递）","text":"vue组件的定义​ 理解为相当于模块，在一个页面上可存在多个组件（模块） vue组件的好处 便于分工，利于合作 代码的复用性强，可维护性强 vue组件的创建与使用 创建组件的代码要编写在声明vue实例代码的前面 通过Vue.exten()方法和Vue.component()方法创建​ Vue.exten()方法会返回一个创建组件的构造函数，包含一个参数，是组件的配置项 123var NewAssembly =Vue.extend({ template:`&lt;div&gt;hello world&lt;/div&gt;`}) ​ Vue.component()方法是利用上面得到的构造函数去创建实例对象。包含两个参数：组件的名称和组件的构造函数 1Vue.component(&quot;MyAssembly&quot;,NewAssembly) 直接通过Vue.component()方法创建（推荐）123Vue.component(&quot;MyAssembly&quot;,{ template:`&lt;div&gt;hello world&lt;/div&gt;` }) 通过template标签创建​ 在vue的监管范围以外的地方编写template标签并编写内容，需要绑定id 123&lt;template id=&quot;assembly&quot;&gt; &lt;div&gt;这是利用template创建的组件的内容&lt;/div&gt;&lt;/template&gt; ​ 绑定该组件(通过id) 123Vue.component(&quot;MyAssembly&quot;,{ template:&quot;#assembly&quot;}) 通过script标签创建​ 创建script标签并编写内容，需要绑定id，注意需要添加type属性 123&lt;script type=&quot;x-template&quot; id=&quot;assembly&quot;&gt; &lt;div&gt;这是利用script创建的组件的内容&lt;/div&gt;&lt;/script&gt; 注意：无论通过哪种方式创建组件，组件内模板只能存在一个根节点 组件的使用​ 在vue监管的html代码里直接使用自定义的组件名（首字母大写）作为标签名。 注意：标签里不能存在大写字母，如组件名里有大写字母，需要转换小写并且在前面在“-”。首字母直接小写 123&lt;div id=&quot;app&quot;&gt; &lt;my-assemnly&gt;&lt;/my-assemnly&gt;&lt;/div&gt; 在组件里创建子组件​ 在父组件使用components属性，在里面指定子组件的名字，子组件的语法和父组件的写法相同 123456789101112131415Vue.component(&apos;BigBox&apos;, { template: ` &lt;div&gt; 父盒子 &lt;box-son&gt;&lt;/box-son&gt; &lt;/div&gt; `, components: { boxSon: { template: ` &lt;div&gt;&lt;/div&gt; ` }, } }) 在组件内使用指令 组件里创建的data，methods等属性只能在对应的组件内调用，其他地方无法调用 在组件内使用data属性 在组件内，为了防止多个组件公用同一个数据，所以data属性的格式必须是函数，并且将其键值对通过return返回 12345data(){ return{ msg:&apos;hello world&apos; }} 组件间传递信息父传子 在子组件中定义一个专门接收从父组件传递过来的数据的容器：props 1234567components: { boxSon: { template: ` &lt;div&gt;这是子代盒子:{{name}}&lt;/div&gt; `, props: [&quot;name&quot;] } 通过v-bind指令，在父组件的模板里的子组件标签动态绑定属性（子组件容器的名字=父组件data里声明的名字） 在子组件里吧props里的数据用插值表达式取出来 1234567891011121314151617181920212223242526Vue.component(&apos;boxC&apos;, { template: ` &lt;div&gt;这是父代盒子：{{sonName}} &lt;box-son v-bind:name=&quot;sonName&quot;&gt;&lt;/box-son&gt; &lt;/div&gt; `, data() { return { sonName: &quot;大明&quot;, } }, components: { boxSon: { template: ` &lt;div&gt;这是子代盒子:父盒子传递过来{{onename}}&lt;/div&gt; `, props: [&quot;name&quot;], data(){ return{ onename:this.name } } } } }) props里的值不能直接修改，可以通过data来缓存，然后再修改data里对应的值 123456789template: ` &lt;div&gt;这是子代盒子:父盒子传递过来{{onename}}&lt;/div&gt; `, props: [&quot;name&quot;], data(){ return{ onename:this.name } } 子传父 子组件传递数据给父组件需要在子组件用到$emit()方法，需要借助一个函数的包装放置在methods属性里面 123456methods: { tellUp() { //第一参数：自定义事件名称；第二参数：需要传递给父组件的值的声明 this.$emit(&apos;giveUp&apos;, this.text) } } 在父组件里的子组件标签通过v-on指令去监听子组件传递上来的事件名称，监听到之后，可以执行一个通过参数传递子组件数据的函数 通过这个函数的默认参数，取到从子组件传递过来的值，然后再在data里定义一个变量接收传过来的值 123456789101112131415161718192021222324252627282930313233343536373839Vue.component(&apos;boxC&apos;, { template: ` &lt;div&gt; 这是父盒子：{{mysonname}} &lt;box-son @giveUp=&quot;getUp&quot;&gt;&lt;/box-son&gt; &lt;/div&gt; `, data() { return { mysonname: &apos;&apos;, } }, methods: { getUp(name) { this.mysonname = name } }, components: { //子 boxSon: { template: ` &lt;div&gt;这是子盒子:{{text}} 点击传递给父组件&lt;button @click=&apos;tellUp&apos;&gt;按钮&lt;/button&gt; &lt;/div&gt; `, data() { return { text: &quot;小明&quot; } }, methods: { tellUp() { this.$emit(&apos;giveUp&apos;, this.text) } } } } }); 兄弟组件之间的传递 兄弟组件之间传递信息需要用到事件总线 ，事件总线是一个空的vue实例，将来作为兄弟组件信息传递的桥梁 1var evtBus = new Vue() 在需要传递出去数据的兄弟元素里的methods属性通过事件总线.$emit一个事件，并携带上参数 12345methods: { giveBro() { evtBus.$emit(&apos;emitGiveBro&apos;, this.twoname); } } 在兄弟元素中，通过mounted钩子监听其他兄弟元素发射过来的事件名和值； 监听兄弟元素传递过来的值需要借助于事件总线的$on()方法 $on()方法有两个参数：1.监听事件的名称。2.函数，带一个默认参数，接收传递过来的值 获取到值后可以在data中声明一个变量来存储取到的值，再渲染到页面上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var evtBus = new Vue();//创建一个事件总线 Vue.component(&apos;bigBox&apos;, { template: ` &lt;div&gt; 大盒子 &lt;box-one&gt;&lt;/box-one&gt; &lt;box-two&gt;&lt;/box-two&gt; &lt;/div&gt; `, components: { //子 boxOne: { template: ` &lt;div&gt;子盒子one，下面的盒子叫{{name}}&lt;/div&gt; `, data() { return { name: &apos;???&apos; } }, mounted() { evtBus.$on(&apos;emitGiveBro&apos;, name =&gt; { this.name = name console.log(name); }) } }, boxTwo: { template: ` &lt;div&gt;子盒子two,我是{{twoname}} &lt;button @click=&quot;giveBro&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; `, data() { return { twoname: &quot;小红&quot; } }, methods: { giveBro() { evtBus.$emit(&apos;emitGiveBro&apos;, this.twoname); } } }, } }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/50c39cd3.html"},{"title":"浅谈vue路由","text":"vue中路由的作用就像是在html中的tap栏切换，根据路由规则去加载不用的组件 ​ 依赖插件：vue-router 创建路由流程 创建路由组件 1234//创建路由组件 var index =Vue.componrnt(&apos;Index&apos;,{ template:`&lt;div&gt;&lt;/div&gt;` }) 声明一个VueRouter存放路由的参数 参数说明：name：用于声明该路由参数名；path：路由的路径，前面要加/；component：路由的名字（要与声明此路由的名字相同）； 123456//存放路由参数 var routerSetting =new VueRouter({ routes:[ {name:&apos;index&apos;,path:&apos;/index&apos;,component:index} ] }) 在vue实例中增加router属性 1234567var vm = new Vue({ el: &apos;#app&apos;, //router:*声明路由参数的名字* router:routerSetting, data: { } }) 在vue管辖的范围内通过router-view渲染组件 1234&lt;div id=&quot;app&quot;&gt; &lt;!-- 渲染组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 对于多路由跳转，可以使用router-link标签，里面的to 属性能控制跳转的路径 123&lt;p&gt; &lt;router-link to=&quot;/page&quot;&gt;跳转到分页&lt;/router-link&gt;&lt;/p&gt; ​ 这时就能完成了一个简单的路由跳转了。 其他参数路由嵌套路由在需要嵌套的路由的参数设置里增加children属性，该属性是一个数组，里面放置一个你要嵌套的子路由的参数 12345678{ name:&apos;page134&apos;, path:&apos;/page1&apos;, component:page1, children:[ {name:&apos;son&apos;,path:&apos;son&apos;,component:son} ]} 注意：在children属性里的path是不用加/的 声明一个子路由实例，然后在路由的模板里增加riuter-view标签用作渲染即可。 123456789101112131415var page1 = Vue.component(&apos;page123&apos;,{ template:`&lt;div&gt; 页面1 &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` });//子路由 var son =Vue.component(&apos;son&apos;,{ template:`&lt;div&gt;{{msg}}&lt;/div&gt;`, data () { return { msg:&apos;子路由盒子&apos; } }, }); 路由重定向定义一个参数设置，通过redirect指向要跳转的页面。path设置为*时当点击的链接没有定义的时候，都会跳转到指定页面 1{name: &apos;default&apos;, path: &apos;*&apos;, redirect: &apos;/index&apos; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/fa8a7b62.html"},{"title":"关于REM布局的相关知识","text":"先说说目前为止我所学到的长度单位 px——绝对长度单位，最基本的长度单位，相对于屏幕分辨率来定义元素的大小。 em——相对长度单位，相对于自身的font-size进行定义元素的大小，如果元素自身没有定义font-size，则默认选用浏览器的默认字体大小（浏览器的默认字体大小是16px）。 百分比%——百分比单位，继承父元素的大小，一般用于设置某个盒子的宽度。 rem——相对长度单位。 ​ 设置字体长度单位一般使用px，em，rem（在需要适配多种分辨率的页面，如移动端，就优先使用rem）。 rem的定义：​ rem是CSS3新增加的一个相对单位，它是相对于HTML根元素的font-size的值来对元素进行设置大小的单位，一般应用于需要适配多种分辨率的移动端页面；使用rem单位设置元素大小，可以方便以后对页面的维护（修改HTML的font-size的值即可）。 12345@media screen and (width:640px) {//这里的width是设计稿的宽度 html { font-size: 100px;//默认基础值设置为100 }} 关于rem的使用方法：​ 先给HTML的font-size设置一个基础值，为了方便一般设置为100，这个值设置给HTML的font-size。设置为100后，后面的元素大小设置需要缩小一百倍（比如某个盒子的字体的大小是将要设置为font-size：16px，则此时需要设置为font-size：0.16rem）。 ​ 注意：rem需要配合媒体查询使用（媒体查询：一种css的语法，可以根据设备屏幕的不同来加载对应的css代码） 在页面的css顶部，需要加媒体查询（@media）来设置HTML的font-size。 这是有计算公式的：font-size=要适配的屏幕宽度*基础值/设计稿的宽度 ​ 这里有一个转换多个媒体查询的在线工具，只需要提供设计稿宽度以及基础值，即可生成多个不同宽度对应的媒体查询代码，将其引入你的css中即可使你的页面兼容多个不同分辨率的显示（要放在在你编写的css之前）。 ​ 目前已知的缺陷（数据源自Can I use？）： 基于Chrome 31-34和Chrome的Android版本（如4.4）在根元素具有基于百分比的大小时会出现字体大小错误。 据报道，Android 4.3版浏览器对于Samsung Note II或Android 4.2上的三星Galaxy Tab 2不起作用。 当页面在Chrome中缩小时，以“rem”为尺寸的边框消失。 在伪元素（：before和：after）中使用“line-height”属性时，IE 9,10和11不支持rem单元 导致通常具有Safari 5.1的iPhone 4上的内容显示和滚动问题。 目前为止本人踩过的坑： 部分css初始化代码里设置了元素的line-hight，此时使用rem设置元素大小将会出现布局错乱（行高放大了好几倍）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/665b26b3.html"},{"title":"前端优化方案","text":"总结了当前前端大部分性能优化的相关方法（搬运工） DNS相关何为DNS    DNS（Domain Name System)域名解析系统，可以看做是网络上域名和IP地址相互映射的一个分布式数据库。作用是将域名转换成IP地址反馈给用户计算机，然后用户计算机再根据IP地址找到目标服务器进行访问。 DNS缓存    DNS可以短暂地缓存到客户端，缓存的作用是可以当用户成功的通过域名进入了一个页面后，系统会将此次通过DNS获取到的IP地址暂时缓存到客户端，在以后用户再次输入域名的时候，系统会优先调取缓存在本地的IP地址。通过DNS缓存能减少客户端向DNS获取IP地址所消耗的时间（约20ms-120ms） DNS优化通过DNS缓存    不同的浏览器的DNS缓存机制也不同：IE对DNS记录默认的缓存时间为30分钟，Firefox对DNS记录默认的缓存时间为1分钟，Chrome对DNS记录默认的缓存时间为1分钟。 缓存时间长：能减少DNS重复请求，能有效节省时间 缓存时间段：及时检测服务器的IP变化，保证访问的正确性。 附:各主流浏览器修改DNS缓存时间、清除系统DNS缓存的方法 减少DNS查询次数    如果你的网站里的资源指向多个域名下，那么DNS将会多次查询各个域名对应的IP，这样会消耗时间。理想的做法是将网站的资源都指向一个域名，但这样会带来另一个问题：在HTTP /1.1 中推荐客户端针对每个域只有一定数量的并行度（它的建议是2），那么就会出现下载资源时的排队现象，这样就会降低性能。一般情况下，建议在一个网站里面使用至少2个域，但不多于4个域来提供资源。 DNS预解析    通过该使用html的link标签的rel属性设置为dns-prefetch来启动域名预解析 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//****&quot;&gt;     当加载完当前页面后，客户端将会根据设置的href地址对DNS进行预加载，节省时间。但切记不可滥用该属性 请求数据相关减少HTTP请求对资源进行打包、压缩、合并等操作服务器端开启gzip压缩     服务器开启gzip压缩后，js代码文件大小将会减少约70%，具体开启方法点这里 避免重定向 重定向：客户浏览器发送http请求—-》web服务器接受后发送302/301状态码响应及对应新的location给客户浏览器–》客户浏览器发现是302/301响应，则自动再发送一个新的http请求，请求url是新的location地址—-》服务器根据此请求寻找资源并发送给客户。 所以，重定向也会间接增加了页面打开时事件     另外，要注意的是慎用302重定向，因为：302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”。 减少不必要的请求    这一项包含了很多内容，例如：不必要的CSS、js引入，不必要的DNS预解析等… 优先使用外链    客户端加载页面时，需要在服务器端拉取资源，然而在同一个服务器同时拉取资源是有数量限制的，具体如下： IE6：最大并发数2 IE8+、Firefox、Chrome：最大并发数6 所以，当页面里需要加载的资源多时，可以考虑使用外链，例如：引入CSS、js代码使用CDN，图片多的使用类似七牛等的云存储托管等… js代码（包含引入的代码）编写在html结构底部    IE低版本的内核不会对html结构进行分析，会直接将html从上到下按顺序加载（引入）资源，且在IE6版本中js文件会阻塞后面所有的资源的加载。所以做兼容的伙伴们就要注意了      另外：对于性能优化，可以使用script标签的defer属性来使页面加载完成才执行js代码或者使用async属性来进行异步执行 图片资源优化     使用img-2 。可以代替img标签，它能做到在页面加载时，图片的原图在还没加载完成时，先用一张你准备好的小图片进行模糊显示，等原图加载完成时把图片渲染出来（需要IE11+） 资源懒加载​ webpack懒加载 参考文档：浅谈前端性能优化（九）——DNS解析优化 优化页面的打开速度，要不要了解一下 大前端性能总结 HTTP中的重定向和请求转发的区别 资源并行数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/d55dc7cf.html"},{"title":"常用css/css3代码段","text":"下面是一些常用的css代码片段，仅供参考 效果展示测试：RunJS a标签基于不同格式使用不同样式提示 为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片 123456789101112131415a[href^=&quot;http://&quot;]{ padding-right: 20px; background: url(external.gif) no-repeat center right;}/* emails */a[href^=&quot;mailto:&quot;]{ padding-right: 20px; background: url(email.png) no-repeat center right;}/* pdfs */a[href$=&quot;.pdf&quot;]{ padding-right: 20px; background: url(pdf.png) no-repeat center right;} ### ###背景渐变效果 css中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。 123456789button { background-image: linear-gradient(#5187c4, #1c2f45); background-size: auto 200%; background-position: 0 100%; transition: background-position 0.5s;} button:hover { background-position: 0 0;} 包裹长文本 当遇到文本比容器长的时候，文本将会超出容器，这时，只需要添加两行css 即可调整文本在容器中的排序 1234pre { white-space: pre-line; word-wrap: break-word;} 制造模糊文本 既然可以给盒子添加阴影box-shadow，那么文字也是可以添加阴影的 1234.blurry-text { color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);} 用css动画实现省略号动画通过添加类的方式添加一段小动画，实现简单的加载状态效果，而不是使用gif图 123456789101112131415.loading:after { overflow: hidden; display: inline-block; vertical-align: bottom; animation: ellipsis 2s infinite; content: &quot;\\2026&quot;; /* ascii code for the ellipsis character */}@keyframes ellipsis { from { width: 2px; } to { width: 15px; }} 图片边框偏光12345678910img.polaroid { background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/} css3全屏背景1234567html { background: url(&apos;images/bg.jpg&apos;) no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;} 段落首字符大字12345678p:first-letter{ display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif;} 三角形列表项目符号1234567891011121314151617ul { margin: 0.75em 0; padding: 0 1em; list-style: none;}li:before { content: &quot;&quot;; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative;} css固定页脚12345678910111213#footer { position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444;}/* IE 6 */* html #footer { position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&apos;px&apos;);} IE6下PNG透明修复12345678910111213141516.bg { width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&apos;/folder/yourimage.png&apos;,sizingMethod=&apos;crop&apos;);}/* 1px gif method */img, .png { position: relative; behavior: expression((this.runtimeStyle.behavior=&quot;none&quot;)&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == &quot;IMG&quot; &amp;&amp; this.src.toLowerCase().indexOf(&apos;.png&apos;)&gt;-1?(this.runtimeStyle.backgroundImage = &quot;none&quot;, this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&apos;&quot; + this.src + &quot;&apos;, sizingMethod=&apos;image&apos;)&quot;, this.src = &quot;images/transparent.gif&quot;):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace(&apos;url(&quot;&apos;,&apos;&apos;).replace(&apos;&quot;)&apos;,&apos;&apos;), this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&apos;&quot; + this.origBg + &quot;&apos;, sizingMethod=&apos;crop&apos;)&quot;, this.runtimeStyle.backgroundImage = &quot;none&quot;)),this.pngSet=true));} input输入边框动画12345678910111213141516input[type=text], textarea { -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd;}input[type=text]:focus, textarea:focus { box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1);} css悬浮文本提示 提示文字为对应的a标签内的data-tooltip属性的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061a { border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none;}a:hover,a:focus { color:#36c;}a:active { top:1px; }/* Tooltip styling */a[data-tooltip]:after { border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: &quot;&quot;; display: none; height: 0; width: 0; left: 25%; position: absolute;}a[data-tooltip]:before { background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;}a[data-tooltip]:hover:after { display: block; top: -9px;}a[data-tooltip]:hover:before { display: block; top: -41px;}a[data-tooltip]:active:after { top: -10px;}a[data-tooltip]:active:before { top: -42px;} 灰色圆角按钮12345678910111213141516171819202122232425262728293031.graybtn { -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#ffffff&apos;, endColorstr=&apos;#d1d1d1&apos;); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff;}.graybtn:hover { background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#d1d1d1&apos;, endColorstr=&apos;#ffffff&apos;); background-color:#d1d1d1;}.graybtn:active { position:relative; top:1px;} 带css3特色的横幅1234567891011121314151617181920212223242526272829.featureBanner { position: relative; margin: 20px; padding-left:50px;}.featureBanner:before { content: &quot;11&quot;; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1;}.featureBanner:after { content: &quot;&quot;; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent;} 本文原帖地址：实用的60个CSS代码片段 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/14e60f66.html"},{"title":"前端常用插件及相关工具整理","text":"Write less ,Do more 整理出平时使用到的插件，不定期更新。我在github上的插件库 动画类​ jQuery Easing 动画曲线插件 对元素编写出多种运行速度不等的动画，是使得页面更加具有特色。 ​ jquery.transi 过渡动画，C3定位插件 对指定元素提供简便的定位语法以及动画语法。 ​ fullPage 全屏滚动插件 做出鼠标滚轮滑动一下，切换全屏的元素。一般用于网页的首页。 ​ iscroll-master 支持多平台的滚动插件 兼容移动端以及pc端的滚动事件 bootstrap类bootstrap – 当前最流行的移动端前端框架，具有兼容性强，视觉性优等优点 ​ bootstrap-paginator-master 分页插件 基于bootstrap的分页插件，功能丰富 字体图标类​ 阿里icon – 阿里的字体图标库 ​ glyphicons – 一个外国的字体图标库，bootstrap收录了其中的一部分 ​ BOOTSTRAP GLYPHICONS – bootstrap的字体图标库 ​ font-awesome-4.7.0 Font Awesome字体图标 自带一套字体图标，亮点功能是能通过修改类名快捷设置字体图标的大小以及旋转 兼容类​ fastclick 解决click在移动端上的延迟 vue类​ axios vue基于http库的异步请求封装 ​ vue-router vue路由插件 ​ vue-ECharts vue版ECharts，数据可视化组件 npm install vue-echarts 123//main.jsimport ECharts from &apos;vue-echarts&apos;Vue.component(&apos;chart&apos;, ECharts) 123456&lt;!--*.vue--&gt;&lt;template&gt; &lt;div class=&apos;reports&apos;&gt; &lt;chart :options=&apos;option&apos;&gt;&lt;/chart&gt; &lt;/div&gt;&lt;/template&gt; ​ vue-quill-editor 轻量级富文本编辑器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/d58806e.html"},{"title":"移动端常用样式及兼容相关","text":"本文将提供移动端的常用样式以及各个不同的移动端版本相关兼容问题 本文原帖地址：https://segmentfault.com/a/1190000000410773#articleHeader35 meta标签相关知识H5页面窗口自动调整到设备宽度，并禁止用户缩放页面1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; 忽略将页面中的数字识别为电话号码1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 忽略Android平台中对邮箱地址的识别1&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式12&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- 可选default、black、black-translucent --&gt; 移动端视口通用模板1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果,可以删除--&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;title&gt;viewport通用&lt;/title&gt; &lt;!--根据系统识别宽度--&gt; &lt;script type=&quot;text/javascript&quot;&gt; var phoneWidth = parseInt(window.screen.width); var phoneScale = phoneWidth / 750; var ua = navigator.userAgent; if (/Android (\\d+\\.\\d+)/.test(ua)) { var version = parseFloat(RegExp.$1); if (version &gt; 2.3) { document.write(&apos;&lt;meta name=&quot;viewport&quot; id=&quot;vie&quot; content=&quot;width=750, minimum-scale = &apos; + phoneScale + &apos;, maximum-scale = &apos; + phoneScale + &apos;, target-densitydpi=device-dpi&quot;&gt;&apos;); } else { document.write(&apos;&lt;meta name=&quot;viewport&quot; id=&quot;vie&quot; content=&quot;width=750, target-densitydpi=device-dpi&quot;&gt;&apos;); } } else { document.write(&apos;&lt;meta id=&quot;vie&quot; name=&quot;viewport&quot; content=&quot;width=750, user-scalable=no, target-densitydpi=device-dpi, minimal-ui&quot;&gt;&apos;); } &lt;/script&gt; &lt;link style=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;home.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/app.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页面内容--&gt;&lt;/body&gt;&lt;/html&gt; 移动端问题总结移动端定义font-family各系统的默认字体和常用字体 系统 默认西文字体 默认中文字体 其他常用西文字体 其他常用中文字体 Windows 宋体 宋体 Tahoma、Arial、Verdana、Georgia 微软雅黑、黑体 Android 4.0以下 Droid Sans Droid Sans Fallback Arial 无宋体、无微软雅黑 Android 4.0及以上 Roboto Roboto Arial 无宋体、无微软雅黑 iOS Helvetica Neue Heiti SC (黑体) Tahoma(v7.0)、Arial、Verdana、Georgia STHeiti(v7.0)、无宋体、无微软雅黑 Mac OS X 10.6以下 Helvetica Neue STHeiti (华文黑体) Tahoma、Arial、Verdana、Georgia 宋体、无微软雅黑 Mac OS X 10.6及以上 Helvetica Neue Hiragino Sans GB (冬青黑体简体中文) Tahoma、Arial、Verdana、Georgia 宋体、无微软雅黑 各PC端对字体的支持情况 五大类字体 IE系列 Chrome Firefox sans-serif（无衬线） 支持 不支持 不支持 serif（衬线） 支持 支持 支持 monospace（等宽） 支持 支持 支持 fantasy（梦幻） 支持 支持 支持 cuisive（草体） 不支持 不支持 不支持 各移动端对字体的支持情况 五大类字体 安卓4.0 IOS6.0 WP8 sans-serif（无衬线） 支持 支持 支持 serif（衬线） 支持 支持 支持 monospace（等宽） 支持 支持 支持 fantasy（梦幻） 不支持 支持 不支持 cuisive（草体） 不支持 不支持 不支持 移动端针对个别元素需要调整字体的方法(非全局定义)12345678/*微软雅黑*/.yahei{font-family: &apos;Microsoft Yahei&apos;, &apos;Hiragino Sans GB&apos;, &apos;Microsoft Sans Serif&apos;, &apos;WenQuanYi Micro Hei&apos;, sans-serif!important}/*宋体*/.songti{font-family: &quot;Helvetica Neue&quot;, Helvetica,&quot;Songti SC&quot;, &quot;SimSun&quot;, serif!important}/*楷体*/.kaiti{font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;KaiTi&quot;, &quot;楷体&quot;, &quot;STKaiti&quot;, &quot;华文楷体&quot;, serif!important}/*华文仿宋*/.fangsong{font-family: &quot;Times New Roman&quot;, &quot;Helvetica Neue&quot;, Helvetica, &quot;FangSong&quot;, &quot;仿宋&quot;, &quot;STFangSong&quot;, &quot;华文仿宋&quot;, serif!important} 移动端全局定义字体样式12345678body{ /*移动端项目*/font-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,sans-self;/*pc端(含Mac)项目*/font-family:Tahoma,Arial,”Helvetica Neue“,”Hiragino Sans GB”,Simsun,sans-self;/*移动和pc端项目*/font-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,”Hiragino Sans GB”,Simsun,sans-self;} 结论 各个手机系统有自己的默认字体，且都不支持微软雅黑 如无特殊需求，手机端无需定义中文字体，使用系统默认 英文字体和数字字体可使用 Helvetica ，三种系统都支持 移动端touch事件（滑动）支持webkit、Android touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 TouchEvent touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 支持winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action:none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 移动端click事件延迟300ms历史原因：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟，地址：https://github.com/ftlabs/fas… zepto的touch模块，tap事件也是为了解决在click的延迟问题，地址：http://www.css88.com/doc/zeptojs_api/ 移动端触摸事件响应顺序 ontouchstart ontouchmove ontouchend onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 清除IOS系统手机对input等表单元素的默认样式1.css{-webkit-appearance:none;} 伪元素改变number类型input框的默认样式 123456789input[type=number]::-webkit-textfield-decoration-container { background-color: transparent; }input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none;}input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none;} CSS美化Placeholder（占位符）提示信息的样式兼容12input::-webkit-input-placeholder{color:#AAAAAA;}input:focus::-webkit-input-placeholder{color:#EEEEEE;} 手机对Placeholder提示信息都基本带有默认的样式，兼容各种浏览器的使用方式： 1234.css::-webkit-input-placeholder {color: #777;} /* WebKit browsers */.css:-moz-placeholder {color: #777;opacity: 1;} /* Mozilla Firefox 4 to 18 */.css::-moz-placeholder {color: #777;opacity: 1;} /* Mozilla Firefox 19+ */.css:-ms-input-placeholder {color: #777;} /* Internet Explorer 10+ */ webkit表单输入框placeholder的文字能换行么ios可以，android不行~ 在textarea标签下都可以换行~ 取消a,button等元素被触摸时产生的半透明灰色遮罩或者虚线框问题1a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)} -webkit-tap-highlight-color :当用户点击iOS的Safari浏览器中的链接或JavaScript的可点击的元素时，覆盖显示的高亮颜色。 该属性可以只设置透明度。如果未设置透明度，iOS Safari使用默认的透明度。当透明度设为0，则会禁用此属性；当透明度设为1，元素在点击时不可见。 文档参考：http://www.css88.com/webkit/-webkit-tap-highlight-color/ 关闭手机端横屏或者竖屏自动调整字体大小功能ios使用-webkit-text-size-adjust禁止调整字体大小: 1body{-webkit-text-size-adjust: 100%!important;} text-size-adjust 设为 none 或者 100% 关闭字体大小自动调整功能。 android使用以下代码，该接口只在微信浏览器下有效: 12345678910111213141516171819202122/** * 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小 * 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示 * 仅供参考 */(function(){ if (typeof(WeixinJSBridge) == &quot;undefined&quot;) { document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) { setTimeout(function(){ WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;,{&quot;fontSize&quot;:0}, function(res) { alert(JSON.stringify(res)); }); },0); }); } else { setTimeout(function(){ WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;,{&quot;fontSize&quot;:0}, function(res) { alert(JSON.stringify(res)); }); },0); }})(); 禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片1.css{-webkit-touch-callout: none} -webkit-touch-callout 是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 当你触摸并按住触摸目标时候，禁止或显示系统默认菜单。在iOS上，当你触摸并按住触摸的目标，比如一个链接，Safari浏览器将显示链接有关的系统默认菜单。这个属性可以让你禁用系统默认菜单。 适用于：链接元素比如新窗口打开，img元素比如保存图像等等取值： none：系统默认菜单被禁用 inherit：系统默认菜单不被禁用 禁止ios和android用户选中文字1.css{-webkit-user-select:none} 当然pc端现在也在用禁止用户选中文字，兼容写法： 123456.test{ -webkit-user-select:none; -moz-user-select:none; -o-user-select:none; user-select:none;} 当然有时候pc上也直接写到html代码中，如： 1&lt;div class=&quot;test&quot; onselectstart=&quot;return false;&quot; unselectable=&quot;on&quot;&gt;这里的文本无法被选中&lt;/div&gt; 代码解释： IE6-9不支持该属性，但支持使用标签属性 onselectstart=&quot;return false;&quot; 来达到user-select:none 的效果；Safari和Chrome也支持该标签属性； 直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 unselectable=&quot;on&quot; 来达到user-select:none 的效果；unselectable 的另一个值是 off； 除Chrome和Safari外，在其它浏览器中，如果将文本设置为-ms-user-select:none;，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为-ms-user-select:none; 的区域文本； 对应的脚本特性为userSelect。 实现打电话发短信，发邮件123打电话：&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;发短信：winphone系统无效，&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;发邮件：&lt;a href=&quot;mailTo:10086@qq.com&quot;&gt;10086@qq.com&lt;/a&gt; 发邮件详细参数：参考地址：http://www.cnblogs.com/PeunZhang/p/4952783.html 1、基础写法当浏览者点击这个链接时，浏览器会自动调用默认的客户端电子邮件程序，并在收件人框中自动填上收件人的地址下面 1&lt;a href=&quot;mailto:peun@foxmail.com&quot;&gt;单击这里发电子邮件&lt;/a&gt; 2、在收件人地址后用?cc=开头，填写抄送地址(android存在兼容问题)1&lt;a href=&quot;mailto:peun@foxmail.com?cc=lina@qq.com&quot;&gt;单击这里发电子邮件&lt;/a&gt; 3、紧跟着抄送地址之后，写上&amp;bcc=，填上密件抄送地址(android存在兼容问题)1&lt;a href=&quot;mailto:peun@foxmail.com?cc=lina@qq.com&amp;bcc=luna@qq.com&quot;&gt;单击这里发电子邮件&lt;/a&gt; 4、包含多个收件人、抄送、密件抄送人，用分号隔(;)开多个收件人的地址即可实现1&lt;a href=&quot;mailto:peun@foxmail.com;dana@foxmail.com&quot;&gt;单击这里发电子邮件&lt;/a&gt; 5、包含主题，用?subject=可以填上主题1&lt;a href=&quot;mailto:peun@foxmail.com?subject=【邀请函】&quot;&gt;单击这里发电子邮件&lt;/a&gt; 6、包含内容，用?body=可以填上内容内容包含文本，使用%0A给文本换行 1&lt;a href=&quot;mailto:peun@foxmail.com?body=邀请您参加腾讯onepiece分享%0A%0A期待您的到来%0A%0Apeunzhang&quot;&gt;单击这里发电子邮件&lt;/a&gt; 内容包含链接，含http(s)://等的文本自动转化为链接 1&lt;a href=&quot;mailto:peun@foxmail.com?body=http://www.cnblogs.com/PeunZhang/&quot;&gt;单击这里电子邮件&lt;/a&gt; 内容包含图片，PC端不支持 1&lt;a href=&quot;mailto:peun@foxmail.com?body=&lt;img src=&apos;http://images.cnblogs.com/cnblogs_com/PeunZhang/286351/o_peunzhang_cnblogs_code.png&apos; width=&apos;200&apos; height=&apos;200&apos;&gt;&quot;&gt;单击这里发电子邮件&lt;/a&gt; 7、完整示例，如果mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的每一个都以“&amp;”开头1&lt;a href=&quot;mailto:aaa@xxx.com;bbb@xxx.com;ccc@xxx.com?cc=ddd@yyy.com;eee@yyy.com&amp;bcc=fff@zzz.com&amp;subject=【邀请函】&amp;body=邀请您参加腾讯onepiece分享&quot;&gt;单击这里发电子邮件&lt;/a&gt; 移动端实现类似hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活移动端css的active效果。 直接在body上添加ontouchstart，同样可激活移动端css的active效果，比较推荐这种方式，代码如下： html代码： 12&lt;body ontouchstart&gt;&lt;/body&gt; css代码： 1.btn:active{background-color: red;} 开启硬件加速解决页面闪白，保证动画流畅 123456.css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);} android 上去掉语音输入按钮1input::-webkit-input-speech-button {display: none} 取消input在ios下，输入的时候英文首字母的默认大写1&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt; 屏幕旋转的事件和样式window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； 1234567891011window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert(&quot;横屏:&quot; + window.orientation); case 0: case 180: alert(&quot;竖屏:&quot; + window.orientation); break; }} 样式： 123456789//竖屏时使用的样式@media all and (orientation:portrait) {.css{}}//横屏时使用的样式@media all and (orientation:landscape) {.css{}} IE10（winphone8）表单元素默认外观重置禁用 select 默认下拉箭头 ::-ms-expand 适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 123select::-ms-expand { display: none;} 禁用 radio 和 checkbox 默认样式 ::-ms-check 适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 123input[type=radio]::-ms-check,input[type=checkbox]::-ms-check{ display: none;} 禁用PC端表单输入框默认清除按钮 当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear 适用于该清除按钮的修改，同样设置使它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 123input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear{ display: none;} Retina 显示屏的问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 12//例如图片宽高为：200px*200px，那么写法如下.css{width:100px;height:100px;background-size:100px 100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px 1.css{font-size:20px} 移动端设置滚动条的默认样式123456789101112131415161718/* 设置滚动条的样式 */::-webkit-scrollbar { width:12px;}/* 滚动槽 */::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px;}/* 滚动条滑块 */::-webkit-scrollbar-thumb { border-radius:10px; background:rgba(0,0,0,0.1); -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.5);}::-webkit-scrollbar-thumb:window-inactive { background:rgba(255,0,0,0.4);} 为移动端页面中滑动滚动条的时候，添加惯性效果的方法首先设置： 1div{height:100%;overflow-y:auto;} 但是实际在 iPhone 上测试时，发现 Safari（也包括很多 iOS App 内置浏览器使用的 UIWebView）竟然完全禁用掉了著名的「惯性滚动」效果。 但解决方法是有的，令人吃惊的是还非常简单：只有一条 CSS 属性即可解决问题： 1body{-webkit-overflow-scrolling:touch;} 有的同学添加了这一条属性后遇到了向下滑动后页面变成空白的问题，实际上可以通过一条 CSS 属性把页面加载到内存来解决： 1body{-webkit-transform:translate3d(0,0,0);} 注：如果设置了-webkit-overflow-scrolling: touch;那么在IOS系统下对于改变滚动条的默认样式将失效，即上面一条所述。 移动端实现控制文本行数1234567div{ display: -webkit-box; -webkit-line-clamp: 4; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical;} 移动端使用flex让内容平均分配12345&lt;nav&gt; &lt;a href=&quot;#&quot;&gt;a&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;b&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;c&lt;/a&gt;&lt;/nav&gt; 12nav{display:-webkit-flex;display:flex;}a{-webkit-flex:1;flex:1;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/ecf06ca9.html"},{"title":"第一篇文章","text":"​ 经过了断断续续的折腾，终于算是把我的小站给搞好了，要特别感谢进哥的帮忙。附上：进哥的博客 ​ 其实搞这个博客主要的原因是向让自己学会整理学习资料以及闲来无事来…自己瞎折腾吧。 ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/5c2fafc7.html"},{"title":"关于跨域","text":"​ 跨域产生的原因：是浏览器的安全机制，两个不同域名之间发生请求，协议名、端口、ip（域名）之间任意一项有任何的不同，浏览器即判定为跨域，跨域默认是不允许的。 一旦产生跨域问题，浏览器将会报错并提示：Access-Control-Allow-Origin 解决方法1——CROS​ 在ajax请求的url对应的服务器（php）设置：header(“Access-Control-Allow-Origin:*”)。 这里的*号表示这个php文件接受任何其他域名的访问，也可以指定某个域名。 解决方法2 ——使用jsonp 使用jsonp解决跨域是利用了script标签的src属性具有天然的可跨域特性来实现的。 jsonp是通过script的src来发送的 jsonp只能以get方式发送请求 ​ 在前端的script标签里请求php文件，返回的结果会默认调用eval函数，将返回的结果放在eval函数里执行。 eval(string) 如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。 1eval(&quot;alert(这是一个提示框)&quot;) ​ 在script的src向后台发送请求，传递一个前台有的函数名到后台，服务器返回这个函数的调用形式（是字符串，返回到前台时通过eval()执行），在这个调用形式里面拼接用户所需要的数据。 1234567&lt;script&gt; function test(res) { console.log(res); }&lt;/script&gt;&lt;!-- url后面接参数，callback是固定的，=号后面的是要执行的函数名 --&gt;&lt;script src=&quot;http://127.0.0.1/html/day6/index.php?callback=test&quot;&gt;&lt;/script&gt; 12345//读取json文件，返回字符串$data =file_get_contents(&apos;data.json&apos;);//固定写法：将这个函数当做参数返回给前台的test函数执行$callback = $_GET[&apos;callback&apos;];echo $callback.&apos;(&apos;.$data.&apos;)&apos;; 利用ajax​ 在前端页面的ajax里添加dataType:’jsonp’，此时，跨域的错误提示已经不出现了。但是数据还暂时无法获取得到，因为跨域还需要后端的配合。 123456789101112&lt;script&gt; $.ajax({ //不做url传参，后台将随机返回函数名 url: &quot;http://127.0.0.1/html/day6/index.php&quot;, type: &apos;get&apos;, //固定类型为jsonp dataType: &apos;jsonp&apos;, success: function (res) { console.log(res); } })&lt;/script&gt; 12345//读取json文件，返回字符串$data =file_get_contents(&apos;data.json&apos;);//固定写法：将这个函数当做参数返回给前台的test函数执行$callback = $_GET[&apos;callback&apos;];echo $callback.&apos;(&apos;.$data.&apos;)&apos;; 扩展阅读：函数的调用形式 扩展阅读：前端常见跨域解决方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/d93ee61d.html"},{"title":"高效前端·Web优化","text":"本文参考《高效前端：Web高效变成与优化实践》作者：李银城。这本书里面讲述了很多关于如何能使前端代码运行起来更加轻巧的方法。目前，我阅读了这本书的前一章，我写这篇文章是当做写这本书的阅读笔记，记录一些以后可能会用到的实用的方法。 第一章：HTML/CSS优化能使用H5/C3解决的问题就不要用Js导航高亮“导航高亮”在很多页面上都非常常见，特点为：在正常状态下，导航栏里的每一项都是偏暗的，当鼠标指向或点击某一项时，那一项会变成高亮且有可能会有额外的下拉菜单显示出来。 123456789/* css *//* 在正常情况下，给每个导航设置透明度使其变暗 */nav li { opacity:0.5;}/* 激活时高亮 */nav li:hover{ opacity:1;} 一般每个导航项都是指向一个不同的页面，所以在每个页面的body里设置好对应的类名，每一个导航项同样设置好对应的类名。 123456789&lt;!-- home.html --&gt;&lt;body class=&quot;home&quot;&gt;&lt;/body&gt;&lt;!-- buy.html --&gt;&lt;body class=&quot;buy&quot;&gt;&lt;/body&gt;&lt;!-- 导航项里设置类 --&gt;&lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;home&quot;&gt;&lt;/li&gt; &lt;li class=&quot;buy&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 当前页面对应的是哪个导航项时，导航项高亮。 1234/* css */body.home nav li.home{ opacity:1;} 当指向某一个导航项时，可能需要显示出一个隐藏的菜单，为了方便，可以将菜单和导航项写成相邻的元素 12345678&lt;!-- html --&gt;&lt;li class=&quot;user&quot;&gt;用户&lt;/li&gt;&lt;li class=&quot;user-menu&quot;&gt; &lt;ul&gt; &lt;li&gt;设置&lt;/li&gt; &lt;li&gt;退出&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 123456789/* css *//* 当鼠标指向某一个导航项时 */.user:hover + .menu{ display:list-item;}/* 同时为了避免鼠标从导航项处离开时，菜单会消失，所以菜单也需要加 */.menu:hover{ display:list-item;} 此时，菜单和导航是挨在一起的，如果使用定位将他们两个隔开，那么上面设置的hover也就失效了，这是，可以使用伪类来实现定位。 123456789/* css */ui.menu:before{ content:&quot;&quot;; position:absolute; left:0; top:-20px; width:100%; height:20px;} 这样鼠标下移的时候会触发menu的hover上，而且也能保持有适当的间距。 多列等高多个盒子并排时，可能会因为盒子里的内容不相同而导致每个盒子的高度都不相同。这时，可以利用table的自适应特性，让每个盒子都当做一天td。 1234567891011/* css *//* 无需修改html结构，直接通过css设置table */.wrapper{ display:table; border-spacing:20px; /* 设置每个td的间距 */}.wrapper{ disaply:table-cell; width:1000px; /* 设置总宽度，会自动平分里面的每一项 */ border-radius:6px; /* 设置圆角，为了美观 */} 根据元素个数的不同显示不同的样式需求如下：有A和B两个元素，当页面上只有A元素时，显示A元素；当页面有A和B甚至更多的元素时，隐藏A元素。 这种情况下可能很多人都会选择使用Js来进行动态判断，其实这里用css3的选择器即可实现。 123456789&lt;!-- html --&gt;&lt;style&gt; /* 当第一个item是第一个元素，且是倒数第二个元素时，隐藏之 */ .item:nth-of-type(1):nth-last-of-type(2){ display:none; }&lt;/style&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt; 基本的表单验证（巧用css3伪类）对于验证email输入的格式可以使用CSS3的选择器valid和invalid。 12345678910111213141516171819&lt;!-- html --&gt;&lt;style&gt; /* 如果输入的内容不是email，则套用这个样式 */ input[type=&quot;email&quot;]:invalid+button{ opacity: 0.5; cursor:not-allowed; pointer-events:none; } /* 如果输入的内容是email，则套用这个样式 */ input[type=&quot;email&quot;]:valid+button{ opacity: 1; cursor: pointer; pointer-events: auto; }&lt;/style&gt;&lt;body&gt; &lt;input type=&quot;email&quot;&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;/body&gt; pointer-events：CSS 属性 指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的目标。以我个人的理解，就是能让指定元素的事件被阻止。里面有多个属性值，但大部分只适用于SVG，只有两个值是可以使用在所有元素： auto：默认，相当于允许元素的事件被触发； none：元素永远不会成为鼠标事件的目标。但是如果这个元素的后代元素的这个属性的值指定为非none时，鼠标事件可以指向后代元素。相当于触发事件冒泡。 对元素hover时显示提示信息想要用户在鼠标指向某一个元素时显示信息，一般情况下我们可以使用title属性，但是效果不是十分理想，这时可以使用css3的attr属性将要展示的文字放在一个属性里。这时，当鼠标指向“伙计”时，就会展示data-title里面的内容。 123456789101112131415161718&lt;!-- html --&gt;&lt;style&gt;span[data-title] { position: relative; } span[data-title]:hover:before { content: attr(data-title); position: absolute; top: 150%; left: 50%; width: 50px; white-space: nowrap; background: #09f; padding: 4px; border-radius: 2px; }&lt;/style&gt;&lt;p&gt;你好啊,&lt;span data-title=&quot;展示出来的内容&quot;&gt;伙计&lt;/span&gt;&lt;/p&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/posts/ac8702bc.html"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"vsCode","slug":"vsCode","link":"/tags/vsCode/"},{"name":"网络交互","slug":"网络交互","link":"/tags/网络交互/"},{"name":"杂","slug":"杂","link":"/tags/杂/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"后端","slug":"后端","link":"/tags/后端/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"优化","slug":"优化","link":"/tags/优化/"},{"name":"阅读笔记","slug":"阅读笔记","link":"/tags/阅读笔记/"}],"categories":[{"name":"资料类","slug":"资料类","link":"/categories/资料类/"},{"name":"学习笔记类","slug":"学习笔记类","link":"/categories/学习笔记类/"},{"name":"模板类","slug":"模板类","link":"/categories/模板类/"},{"name":"杂项","slug":"杂项","link":"/categories/杂项/"}]}